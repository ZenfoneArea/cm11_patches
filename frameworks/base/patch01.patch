diff --git a/api/current.txt b/api/current.txt
index 100b288..f4c7930 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -17424,6 +17424,8 @@ package android.os {
     field public static final java.lang.String FINGERPRINT;
     field public static final java.lang.String HARDWARE;
     field public static final java.lang.String HOST;
+    field public static final java.lang.String HOUDINI_ABI = "armeabi-v7a";
+    field public static final java.lang.String HOUDINI_ABI2 = "armeabi";
     field public static final java.lang.String ID;
     field public static final java.lang.String MANUFACTURER;
     field public static final java.lang.String MODEL;
diff --git a/cmds/app_process/app_main.cpp b/cmds/app_process/app_main.cpp
index 28752a5..f6632fa 100644
--- a/cmds/app_process/app_main.cpp
+++ b/cmds/app_process/app_main.cpp
@@ -16,6 +16,8 @@
 #include <cutils/trace.h>
 #include <android_runtime/AndroidRuntime.h>
 #include <sys/personality.h>
+#include <sys/utsname.h>
+#include <sys/resource.h>
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -164,6 +166,44 @@ int main(int argc, char* const argv[])
     unsetenv("NO_ADDR_COMPAT_LAYOUT_FIXUP");
 #endif
 
+#ifdef __i386__
+    struct utsname u_name;
+    if (uname(&u_name) == -1) {
+        fprintf(stderr, "Error: uname call failed.\n");
+    } else {
+        char value[PROPERTY_VALUE_MAX];
+        int ret;
+        ret = property_get("ro.config.personality", value, "");
+        if (ret && !strcmp(value, "compat_layout")
+                && (getenv("NO_ADDR_COMPAT_LAYOUT_FIXUP") == NULL)) {
+            int old_personality;
+            old_personality = personality((unsigned long)-1);
+            if (!strcmp(u_name.machine, "x86_64")
+                    && !(old_personality & ADDR_LIMIT_3GB)) {
+                /* In zygote, set stack limit to force mmap/heap area initially
+                 * below 2G, so as to workaround buggy applications that assume
+                 * positive memory address.
+                 * NOTE: A 64bit kernel allows either a 3G or 4G user space for
+                 * a 32bit application. In the case of a 3G user address space,
+                 * the 0x90000000 magic number is incorrect and Houdini apps
+                 * may fail, but tuning has shown it generally allows Houdini
+                 * apps to run successfully.
+                 */
+                struct rlimit rlim;
+                rlim.rlim_max = rlim.rlim_cur = 0x90000000;
+                int res = 0;
+                res = setrlimit(RLIMIT_STACK, &rlim);
+            } else {
+                personality(old_personality | ADDR_COMPAT_LAYOUT);
+            }
+            setenv("NO_ADDR_COMPAT_LAYOUT_FIXUP", "1", 1);
+            execv("/system/bin/app_process", argv);
+            return -1;
+        }
+        unsetenv("NO_ADDR_COMPAT_LAYOUT_FIXUP");
+    }
+#endif
+
     // These are global variables in ProcessState.cpp
     mArgC = argc;
     mArgV = argv;
diff --git a/core/java/android/content/pm/PackageManager.java b/core/java/android/content/pm/PackageManager.java
index d21692e..13114e6 100644
--- a/core/java/android/content/pm/PackageManager.java
+++ b/core/java/android/content/pm/PackageManager.java
@@ -370,6 +370,23 @@ public abstract class PackageManager {
     public static final int INSTALL_SUCCEEDED = 1;
 
     /**
+     * Native Library Copy return code: this is passed to {@link PackageManagerService} by
+     * {@link NativeLibararyHelper} on successful copy of native library.
+     * It indicates that the native library being copied matches 2nd ABI.
+     * @hide
+     */
+
+    public static final int INSTALL_ABI2_SUCCEEDED = 2;
+
+    /**
+     * Native Library Copy return code: this is passed to {@link PackageManagerService} by
+     * {@link NativeLibararyHelper} on package with x86 lib in the assets folder.
+     * @hide
+     */
+
+    public static final int INSTALL_IMPLICIT_ABI_SUCCEEDED = 4;
+
+    /**
      * Installation return code: this is passed to the {@link IPackageInstallObserver} by
      * {@link #installPackage(android.net.Uri, IPackageInstallObserver, int)} if the package is
      * already installed.
diff --git a/core/java/android/os/Build.java b/core/java/android/os/Build.java
index bc51a60..2d71870 100644
--- a/core/java/android/os/Build.java
+++ b/core/java/android/os/Build.java
@@ -46,6 +46,10 @@ public class Build {
     /** The name of the second instruction set (CPU type + ABI convention) of native code. */
     public static final String CPU_ABI2 = getString("ro.product.cpu.abi2");
 
+    /** The name of instruction set (CPU type + ABI convention) for Houdini app. */
+    public static final String HOUDINI_ABI = "armeabi-v7a";
+    public static final String HOUDINI_ABI2 = "armeabi";
+
     /** The manufacturer of the product/hardware. */
     public static final String MANUFACTURER = getString("ro.product.manufacturer");
 
diff --git a/core/java/com/android/internal/content/NativeLibraryHelper.java b/core/java/com/android/internal/content/NativeLibraryHelper.java
index 6d65782..88ff5fc 100644
--- a/core/java/com/android/internal/content/NativeLibraryHelper.java
+++ b/core/java/com/android/internal/content/NativeLibraryHelper.java
@@ -16,7 +16,9 @@
 
 package com.android.internal.content;
 
+import android.content.pm.PackageManager;
 import android.os.Build;
+import android.os.SystemProperties;
 import android.util.Slog;
 
 import java.io.File;
@@ -30,6 +32,7 @@ public class NativeLibraryHelper {
     private static final String TAG = "NativeHelper";
 
     private static final boolean DEBUG_NATIVE = false;
+    private static final boolean ENABLE_HOUDINI = Build.CPU_ABI.equals("x86") && (Build.CPU_ABI2.length()!=0);
 
     private static native long nativeSumNativeBinaries(String file, String cpuAbi, String cpuAbi2);
 
@@ -42,9 +45,45 @@ public class NativeLibraryHelper {
     public static long sumNativeBinariesLI(File apkFile) {
         final String cpuAbi = Build.CPU_ABI;
         final String cpuAbi2 = Build.CPU_ABI2;
-        return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+
+        if (ENABLE_HOUDINI) {
+            long result = nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+            if (result == 0) {
+                final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi", "armeabi");
+                result = nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, abiUpgrade);
+            }
+            return result;
+        } else {
+            return nativeSumNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+        }
     }
 
+    private static native int nativeListNativeBinaries(String file, String cpuAbi, String cpuAbi2);
+
+    /**
+     * List the native binaries info in an APK.
+     *
+     * @param apkFile APK file to scan for native libraries
+     * @return {@link PackageManager#INSTALL_SUCCEEDED} or {@link PackageManager#INSTALL_ABI2_SUCCEEDED}
+     *         or another error code from that class if not
+     */
+    public static int listNativeBinariesLI(File apkFile) {
+        final String cpuAbi = Build.CPU_ABI;
+        final String cpuAbi2 = Build.CPU_ABI2;
+
+        if (ENABLE_HOUDINI) {
+            int result = nativeListNativeBinaries(apkFile.getPath(), cpuAbi, cpuAbi2);
+            if ((result != PackageManager.INSTALL_SUCCEEDED) && (result != PackageManager.INSTALL_ABI2_SUCCEEDED)) {
+                final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi", "armeabi");
+                result = nativeListNativeBinaries(apkFile.getPath(), cpuAbi, abiUpgrade);
+            }
+            return result;
+        } else {
+            return PackageManager.INSTALL_SUCCEEDED;
+        }
+    }
+
+
     private native static int nativeCopyNativeBinaries(String filePath, String sharedLibraryPath,
             String cpuAbi, String cpuAbi2);
 
@@ -53,14 +92,23 @@ public class NativeLibraryHelper {
      *
      * @param apkFile APK file to scan for native libraries
      * @param sharedLibraryDir directory for libraries to be copied to
-     * @return {@link PackageManager#INSTALL_SUCCEEDED} if successful or another
-     *         error code from that class if not
+     * @return {@link PackageManager#INSTALL_SUCCEEDED} or {@link PackageManager#INSTALL_ABI2_SUCCEEDED}
+     *         if successful or another error code from that class if not
      */
     public static int copyNativeBinariesIfNeededLI(File apkFile, File sharedLibraryDir) {
         final String cpuAbi = Build.CPU_ABI;
         final String cpuAbi2 = Build.CPU_ABI2;
-        return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi,
-                cpuAbi2);
+
+        if (ENABLE_HOUDINI) {
+            int result = nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi, cpuAbi2);
+            if ((result != PackageManager.INSTALL_SUCCEEDED) && (result != PackageManager.INSTALL_ABI2_SUCCEEDED)) {
+                final String abiUpgrade = SystemProperties.get("ro.product.cpu.upgradeabi", "armeabi");
+                result = nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi, abiUpgrade);
+            }
+            return result;
+        } else {
+            return nativeCopyNativeBinaries(apkFile.getPath(), sharedLibraryDir.getPath(), cpuAbi, cpuAbi2);
+        }
     }
 
     // Convenience method to call removeNativeBinariesFromDirLI(File)
diff --git a/core/java/com/android/internal/os/ZygoteConnection.java b/core/java/com/android/internal/os/ZygoteConnection.java
index f5abacf..f5b1d9b 100644
--- a/core/java/com/android/internal/os/ZygoteConnection.java
+++ b/core/java/com/android/internal/os/ZygoteConnection.java
@@ -19,6 +19,7 @@ package com.android.internal.os;
 import android.graphics.Typeface;
 import android.net.Credentials;
 import android.net.LocalSocket;
+import android.os.Build;
 import android.os.Process;
 import android.os.SELinux;
 import android.os.SystemProperties;
diff --git a/core/jni/Android.mk b/core/jni/Android.mk
index 04215c5..e6b1dbb 100644
--- a/core/jni/Android.mk
+++ b/core/jni/Android.mk
@@ -255,6 +255,12 @@ ifeq ($(WITH_MALLOC_LEAK_CHECK),true)
 	LOCAL_CFLAGS += -DMALLOC_LEAK_CHECK
 endif
 
+ifeq ($(INTEL_HOUDINI), true)
+    LOCAL_CFLAGS += -DWITH_HOUDINI
+	LOCAL_SHARED_LIBRARIES += libdvm
+    LOCAL_STATIC_LIBRARIES += libhoudini_hook
+endif
+
 LOCAL_MODULE:= libandroid_runtime
 
 include external/stlport/libstlport.mk
diff --git a/core/jni/AndroidRuntime.cpp b/core/jni/AndroidRuntime.cpp
index 8518101..62f2b5c 100644
--- a/core/jni/AndroidRuntime.cpp
+++ b/core/jni/AndroidRuntime.cpp
@@ -44,7 +44,6 @@
 #include <dirent.h>
 #include <assert.h>
 
-
 using namespace android;
 
 extern int register_android_os_Binder(JNIEnv* env);
diff --git a/core/jni/android_app_NativeActivity.cpp b/core/jni/android_app_NativeActivity.cpp
index 5418006..ccd2ccc 100644
--- a/core/jni/android_app_NativeActivity.cpp
+++ b/core/jni/android_app_NativeActivity.cpp
@@ -41,6 +41,14 @@
 #define LOG_TRACE(...)
 //#define LOG_TRACE(...) ALOG(LOG_DEBUG, LOG_TAG, __VA_ARGS__)
 
+#ifdef WITH_HOUDINI
+namespace houdini {
+void* hookDlopen(const char* filename, int flag, bool* useHoudini);
+void* hookDlsym(bool useHoudini, void* handle, const char* symbol);
+void  hookCreateActivity(bool useHoudini, void* createActivityFunc, void* activity, void*houdiniActivity, void* savedState, size_t savedStateSize);
+}
+#endif
+
 namespace android
 {
 
@@ -109,6 +117,9 @@ struct NativeCode : public ANativeActivity {
         createActivityFunc = _createFunc;
         nativeWindow = NULL;
         mainWorkRead = mainWorkWrite = -1;
+#ifdef WITH_HOUDINI
+        houdiniNativeActivity = NULL;
+#endif
     }
     
     ~NativeCode() {
@@ -130,6 +141,10 @@ struct NativeCode : public ANativeActivity {
             // is really no benefit to unloading the code.
             //dlclose(dlhandle);
         }
+#ifdef WITH_HOUDINI
+        if (houdiniNativeActivity != NULL)
+            delete houdiniNativeActivity;
+#endif
     }
     
     void setSurface(jobject _surface) {
@@ -157,6 +172,9 @@ struct NativeCode : public ANativeActivity {
     int mainWorkRead;
     int mainWorkWrite;
     sp<MessageQueue> messageQueue;
+#ifdef WITH_HOUDINI
+    ANativeActivity *houdiniNativeActivity;
+#endif
 };
 
 void android_NativeActivity_finish(ANativeActivity* activity) {
@@ -252,14 +270,24 @@ loadNativeCode_native(JNIEnv* env, jobject clazz, jstring path, jstring funcName
     const char* pathStr = env->GetStringUTFChars(path, NULL);
     NativeCode* code = NULL;
     
+#ifdef WITH_HOUDINI
+    bool useHoudini = false;
+    void* handle = houdini::hookDlopen(pathStr, RTLD_LAZY, &useHoudini);
+#else
     void* handle = dlopen(pathStr, RTLD_LAZY);
+#endif
     
     env->ReleaseStringUTFChars(path, pathStr);
     
     if (handle != NULL) {
         const char* funcStr = env->GetStringUTFChars(funcName, NULL);
+#ifdef WITH_HOUDINI
+        code = new NativeCode(handle, (ANativeActivity_createFunc*)
+                houdini::hookDlsym(useHoudini, handle, funcStr));
+#else
         code = new NativeCode(handle, (ANativeActivity_createFunc*)
                 dlsym(handle, funcStr));
+#endif
         env->ReleaseStringUTFChars(funcName, funcStr);
         
         if (code->createActivityFunc == NULL) {
@@ -331,7 +359,22 @@ loadNativeCode_native(JNIEnv* env, jobject clazz, jstring path, jstring funcName
             rawSavedSize = env->GetArrayLength(savedState);
         }
 
+#ifdef WITH_HOUDINI
+        if (useHoudini) {
+            /*
+             * If houdini is used, code is used by x86 code. So we create
+             * a houdini version for code. x86 version will store peer's
+             * pointer in houdiniNativeActivity each other.
+             */
+            code->houdiniNativeActivity = new ANativeActivity;
+            *code->houdiniNativeActivity = *(ANativeActivity *)code;
+        }
+
+        houdini::hookCreateActivity(useHoudini, (void*)code->createActivityFunc, (void*)code,
+                (void*)code->houdiniNativeActivity, (void*)rawSavedState, rawSavedSize);
+#else
         code->createActivityFunc(code, rawSavedState, rawSavedSize);
+#endif
 
         if (rawSavedState != NULL) {
             env->ReleaseByteArrayElements(savedState, rawSavedState, 0);
diff --git a/core/jni/android_net_wifi_WifiNative.cpp b/core/jni/android_net_wifi_WifiNative.cpp
index b3c4e28..1804c95 100644
--- a/core/jni/android_net_wifi_WifiNative.cpp
+++ b/core/jni/android_net_wifi_WifiNative.cpp
@@ -22,7 +22,7 @@
 
 #include "wifi.h"
 
-#define REPLY_BUF_SIZE 4096 // wpa_supplicant's maximum size.
+#define REPLY_BUF_SIZE 12288 // wpa_supplicant's maximum size.
 #define EVENT_BUF_SIZE 2048
 
 #define CONVERT_LINE_LEN 2048
diff --git a/core/jni/com_android_internal_content_NativeLibraryHelper.cpp b/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
index 3507a9f..bcb3f15 100644
--- a/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
+++ b/core/jni/com_android_internal_content_NativeLibraryHelper.cpp
@@ -54,8 +54,14 @@ namespace android {
 // These match PackageManager.java install codes
 typedef enum {
     INSTALL_SUCCEEDED = 1,
+#ifdef WITH_HOUDINI
+    INSTALL_ABI2_SUCCEEDED = 2,
+#endif
     INSTALL_FAILED_INVALID_APK = -2,
     INSTALL_FAILED_INSUFFICIENT_STORAGE = -4,
+#ifdef WITH_HOUDINI
+    INSTALL_FAILED_CPU_ABI_INCOMPATIBLE = -16,
+#endif
     INSTALL_FAILED_CONTAINER_ERROR = -18,
     INSTALL_FAILED_INTERNAL_ERROR = -110,
 } install_status_t;
@@ -157,6 +163,12 @@ sumFiles(JNIEnv* env, void* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, const
     return INSTALL_SUCCEEDED;
 }
 
+static install_status_t
+listFiles(JNIEnv* env, void* arg, ZipFileRO* zipFile, ZipEntryRO zipEntry, const char* fileName)
+{
+    return INSTALL_SUCCEEDED;
+}
+
 /*
  * Copy the native library if needed.
  *
@@ -284,6 +296,10 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
 
     char fileName[PATH_MAX];
     bool hasPrimaryAbi = false;
+#ifdef WITH_HOUDINI
+    bool useSecondaryAbi = false;
+    bool noMatchAbi = false;
+#endif
 
     for (int i = 0; i < N; i++) {
         const ZipEntryRO entry = zipFile.findEntryByIndex(i);
@@ -333,9 +349,15 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
                 ALOGV("Already saw primary ABI, skipping secondary ABI %s\n", cpuAbi2.c_str());
                 continue;
             } else {
+#ifdef WITH_HOUDINI
+                useSecondaryAbi = true;
+#endif
                 ALOGV("Using secondary ABI %s\n", cpuAbi2.c_str());
             }
         } else {
+#ifdef WITH_HOUDINI
+            noMatchAbi = true;
+#endif
             ALOGV("abi didn't match anything: %s (end at %zd)\n", cpuAbiOffset, cpuAbiRegionSize);
             continue;
         }
@@ -355,6 +377,14 @@ iterateOverNativeFiles(JNIEnv *env, jstring javaFilePath, jstring javaCpuAbi, js
         }
     }
 
+#ifdef WITH_HOUDINI
+    if (!hasPrimaryAbi && !useSecondaryAbi && noMatchAbi)
+        return INSTALL_FAILED_CPU_ABI_INCOMPATIBLE;
+
+    if (!hasPrimaryAbi && useSecondaryAbi)
+        return INSTALL_ABI2_SUCCEEDED;
+#endif
+
     return INSTALL_SUCCEEDED;
 }
 
@@ -377,6 +407,17 @@ com_android_internal_content_NativeLibraryHelper_sumNativeBinaries(JNIEnv *env,
     return totalSize;
 }
 
+static jint
+com_android_internal_content_NativeLibraryHelper_listNativeBinaries(JNIEnv *env, jclass clazz,
+        jstring javaFilePath, jstring javaCpuAbi, jstring javaCpuAbi2)
+{
+#ifndef WITH_HOUDINI
+    return (jint) INSTALL_SUCCEEDED;
+#else
+    return (jint) iterateOverNativeFiles(env, javaFilePath, javaCpuAbi, javaCpuAbi2, listFiles, NULL);
+#endif
+}
+
 static JNINativeMethod gMethods[] = {
     {"nativeCopyNativeBinaries",
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
@@ -384,6 +425,9 @@ static JNINativeMethod gMethods[] = {
     {"nativeSumNativeBinaries",
             "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)J",
             (void *)com_android_internal_content_NativeLibraryHelper_sumNativeBinaries},
+    {"nativeListNativeBinaries",
+            "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)I",
+            (void *)com_android_internal_content_NativeLibraryHelper_listNativeBinaries},
 };
 
 
diff --git a/core/jni/com_android_internal_os_ZygoteInit.cpp b/core/jni/com_android_internal_os_ZygoteInit.cpp
index 44452f0..9b271a4 100644
--- a/core/jni/com_android_internal_os_ZygoteInit.cpp
+++ b/core/jni/com_android_internal_os_ZygoteInit.cpp
@@ -22,6 +22,7 @@
 #include <utils/misc.h>
 #include <errno.h>
 #include <sys/select.h>
+#include <dlfcn.h>
 
 #include "jni.h"
 #include <JNIHelp.h>
@@ -281,6 +282,7 @@ static JNINativeMethod gMethods[] = {
     { "createFileDescriptor", "(I)Ljava/io/FileDescriptor;",
         (void *) com_android_internal_os_ZygoteInit_createFileDescriptor }
 };
+
 int register_com_android_internal_os_ZygoteInit(JNIEnv* env)
 {
     return AndroidRuntime::registerNativeMethods(env,
diff --git a/services/java/com/android/server/VibratorService.java b/services/java/com/android/server/VibratorService.java
index e8f399e..aad2e2f 100644
--- a/services/java/com/android/server/VibratorService.java
+++ b/services/java/com/android/server/VibratorService.java
@@ -83,6 +83,12 @@ public class VibratorService extends IVibratorService.Stub
     native static boolean vibratorExists();
     native static void vibratorOn(long milliseconds);
     native static void vibratorOff();
+    // Due to vibrator lag time, vibrations under certain threshold cannot be felt.
+    // To compensate this, the HAL returns the minimum timeout allowed for a short vibration.
+    native static long getVibratorMinTimeout();
+
+    // Get lower vibration timeout limit from HAL if any
+    private static final long mVibratorMinTimeout = getVibratorMinTimeout();
 
     private class Vibration implements IBinder.DeathRecipient {
         private final IBinder mToken;
@@ -378,8 +384,9 @@ public class VibratorService extends IVibratorService.Stub
         } catch (RemoteException e) {
         }
         if (vib.mTimeout != 0) {
-            doVibratorOn(vib.mTimeout, vib.mUid);
-            mH.postDelayed(mVibrationRunnable, vib.mTimeout);
+            long effectiveVibTimeout = Math.max(vib.mTimeout, mVibratorMinTimeout);
+            doVibratorOn(effectiveVibTimeout, vib.mUid);
+            mH.postDelayed(mVibrationRunnable, effectiveVibTimeout);
         } else {
             // mThread better be null here. doCancelVibrate should always be
             // called before startNextVibrationLocked or startVibrationLocked.
diff --git a/services/java/com/android/server/net/NetworkStatsService.java b/services/java/com/android/server/net/NetworkStatsService.java
index a86f8ce..1d46c82 100644
--- a/services/java/com/android/server/net/NetworkStatsService.java
+++ b/services/java/com/android/server/net/NetworkStatsService.java
@@ -942,7 +942,11 @@ public class NetworkStatsService extends INetworkStatsService.Stub {
     private void performPoll(int flags) {
         // try refreshing time source when stale
         if (mTime.getCacheAge() > mSettings.getTimeCacheMaxAge()) {
-            mTime.forceRefresh();
+            new Thread(new Runnable() {
+                public void run() {
+                    mTime.forceRefresh();
+                }
+            }).start();
         }
 
         synchronized (mStatsLock) {
diff --git a/services/java/com/android/server/pm/CheckExt.java b/services/java/com/android/server/pm/CheckExt.java
index e69de29..d4743b0 100644
--- a/services/java/com/android/server/pm/CheckExt.java
+++ b/services/java/com/android/server/pm/CheckExt.java
@@ -0,0 +1,46 @@
+package com.android.server.pm;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.util.List;
+import java.util.ArrayList;
+
+/*
+ * class CheckExt is trying to check params
+ */
+public class CheckExt implements ICheckExt {
+    final private String TAG = "CheckExt";
+    private List<ICheckExt> checklist;
+
+    public CheckExt() {
+        checklist = new ArrayList<ICheckExt>();
+        ICheckExt check = new xmlCheckExt();
+        checklist.add(check);
+    }
+
+    public boolean doCheck(String... params) {
+        if (checklist.size() == 0)
+            return false;
+        ICheckExt check;
+        for (int i = 0; i < checklist.size(); i++) {
+            check = checklist.get(i);
+            if(check.doCheck(params))
+                return true;
+
+        }
+        return false;
+    }
+}
diff --git a/services/java/com/android/server/pm/ICheckExt.java b/services/java/com/android/server/pm/ICheckExt.java
index e69de29..e540b16 100644
--- a/services/java/com/android/server/pm/ICheckExt.java
+++ b/services/java/com/android/server/pm/ICheckExt.java
@@ -0,0 +1,30 @@
+package com.android.server.pm;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+public interface ICheckExt {
+
+    /*Function: doCheck
+     *Description:
+     * check parameters to decide whether it should pass or not
+     *Parameter:
+     * params : parameters for apk to check
+     *Return:
+     * true - check pass
+     * false - check fail
+     */
+    boolean doCheck(String... params);
+}
diff --git a/services/java/com/android/server/pm/PackageManagerService.java b/services/java/com/android/server/pm/PackageManagerService.java
index f444fb7..3971c7b 100644
--- a/services/java/com/android/server/pm/PackageManagerService.java
+++ b/services/java/com/android/server/pm/PackageManagerService.java
@@ -218,6 +218,7 @@ public class PackageManagerService extends IPackageManager.Stub {
     private static final boolean DEBUG_PACKAGE_SCANNING = false;
     private static final boolean DEBUG_APP_DIR_OBSERVER = false;
     private static final boolean DEBUG_VERIFY = false;
+    private static final boolean ENABLE_HOUDINI = Build.CPU_ABI.equals("x86") && (Build.CPU_ABI2.length()!=0);
 
     private static final int RADIO_UID = Process.PHONE_UID;
     private static final int LOG_UID = Process.LOG_UID;
@@ -596,6 +597,11 @@ public class PackageManagerService extends IPackageManager.Stub {
     // or internal storage.
     private IMediaContainerService mContainerService = null;
 
+    // Packages that have been installed with library matching 2nd ABI.
+    final HashMap<Integer, String> mPackagesMatchABI2 = new HashMap<Integer,String>();
+    // Packages that have been installed with library matching 2nd ABI and matching neon app list
+    final HashMap<Integer, String> mPackagesMatchABI2Neon = new HashMap<Integer,String>();
+
     static final int SEND_PENDING_BROADCAST = 1;
     static final int MCS_BOUND = 3;
     static final int END_COPY = 4;
@@ -4325,6 +4331,53 @@ public class PackageManagerService extends IPackageManager.Stub {
         return new File(mUserAppDataDir.getAbsolutePath() + File.separator + userId);
     }
 
+    private void writeAppwithABI2Internal(String fileName, HashMap<Integer, String> map) {
+        File outputFile;
+        FileOutputStream out = null;
+        File appDataDir = new File("/data/data");
+
+        try {
+            File tempFile = File.createTempFile("tmp", "tmp", appDataDir);
+            String tempFilePath = tempFile.getPath();
+            outputFile = new File(fileName);
+            if (FileUtils.setPermissions(tempFilePath,
+                FileUtils.S_IRUSR | FileUtils.S_IWUSR |
+                FileUtils.S_IRGRP | FileUtils.S_IROTH, -1, -1) != 0
+                || !tempFile.renameTo(outputFile)) {
+                tempFile.delete();
+            }
+            out = new FileOutputStream(outputFile);
+            Iterator<HashMap.Entry<Integer, String>>
+            it = map.entrySet().iterator();
+            while (it.hasNext()) {
+                HashMap.Entry<Integer, String> ent = it.next();
+                int userID = ent.getKey().intValue();
+                out.write(userID & 0xff);
+                out.write((userID>>8)  & 0xff);
+                out.write((userID>>16) & 0xff);
+                out.write((userID>>24) & 0xff);
+                Slog.i(TAG, "Data written:"+ userID);
+            }
+        } catch (Exception e) {
+            Slog.e(TAG, "File Access Error: Not Able to write Data into " + fileName);
+        } finally {
+            try {
+                if (out != null) {
+                    out.close();
+                    Slog.i(TAG, "Data written into " + fileName);
+                }
+            } catch (IOException e) {}
+        }
+    }
+
+    private void writeAppwithABI2() {
+        writeAppwithABI2Internal(new String("/data/data/.appwithABI2"), mPackagesMatchABI2);
+    }
+
+    private void writeAppwithABI2Neon() {
+        writeAppwithABI2Internal(new String("/data/data/.appwithABI2neon"), mPackagesMatchABI2Neon);
+    }
+
     private File getDataPathForPackage(String packageName, int userId) {
         /*
          * Until we fully support multiple users, return the directory we
@@ -4678,6 +4731,25 @@ public class PackageManagerService extends IPackageManager.Stub {
                 Slog.w(TAG, "Package " + pkg.packageName
                         + " was transferred to another, but its .apk remains");
             }
+
+            if (ENABLE_HOUDINI) {
+                PackageSetting p = mSettings.mPackages.get(pkg.packageName);
+                if ((p != null) && (!p.codePath.equals(destCodeFile))){
+
+                   // Already existing package. Make sure not upgrade to black list
+                    int result = NativeLibraryHelper.listNativeBinariesLI(scanFile);
+
+                    if (result == PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                        ICheckExt check = new CheckExt();
+                        if(check.doCheck(pkg.packageName, new String("filter"))){
+                            Slog.i(TAG, "Reject application in black list::" + pkg.packageName);
+                            mLastScanError = PackageManager.INSTALL_FAILED_INVALID_APK;
+                            return null;
+                        }
+                    }
+
+                }
+            }
             
             // Just create the setting, don't add it yet. For already existing packages
             // the PkgSetting exists already and doesn't have to be created.
@@ -4992,10 +5064,21 @@ public class PackageManagerService extends IPackageManager.Stub {
                         }
 
                         try {
-                            if (copyNativeLibrariesForInternalApp(scanFile, nativeLibraryDir) != PackageManager.INSTALL_SUCCEEDED) {
-                                Slog.e(TAG, "Unable to copy native libraries");
-                                mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
-                                return null;
+                            int copyRet = copyNativeLibrariesForInternalApp(scanFile,
+                                    nativeLibraryDir);
+                            if (ENABLE_HOUDINI) {
+                                if (copyRet != PackageManager.INSTALL_SUCCEEDED
+                                        && copyRet != PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                                    Slog.e(TAG, "Unable to copy native libraries");
+                                    mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
+                                    return null;
+                                }
+                            } else {
+                                if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
+                                    Slog.e(TAG, "Unable to copy native libraries");
+                                    mLastScanError = PackageManager.INSTALL_FAILED_INTERNAL_ERROR;
+                                    return null;
+                                }
                             }
                         } catch (IOException e) {
                             Slog.e(TAG, "Unable to copy native libraries", e);
@@ -5004,6 +5087,35 @@ public class PackageManagerService extends IPackageManager.Stub {
                         }
                     }
 
+                    // if the pkg doesn't go through copyNativeLibrariesForInternalApp path
+                    // Need check the apk whether contains ABI2 library.
+                    int result = NativeLibraryHelper.listNativeBinariesLI(scanFile);
+                    if (result == PackageManager.INSTALL_SUCCEEDED) {
+                        if (ENABLE_HOUDINI && mPackagesMatchABI2.containsKey(pkg.applicationInfo.uid)) {
+                            Slog.i(TAG, "Replace package with primary ABI Library");
+                            mPackagesMatchABI2.remove(pkg.applicationInfo.uid);
+                            writeAppwithABI2();
+                            if (mPackagesMatchABI2Neon.containsKey(pkg.applicationInfo.uid)) {
+                                mPackagesMatchABI2Neon.remove(pkg.applicationInfo.uid);
+                                writeAppwithABI2Neon();
+                            }
+                        }
+                    } else if (ENABLE_HOUDINI && result == PackageManager.INSTALL_ABI2_SUCCEEDED && !mPackagesMatchABI2.containsKey(pkg.applicationInfo.uid)) {
+                        ICheckExt check = new CheckExt();
+                        if (check.doCheck(pkgName, new String("filter"))) {
+                            Slog.i(TAG, "Package with second ABI is in black list: " + pkg.applicationInfo.uid + pkg.applicationInfo.processName);
+                            mLastScanError = PackageManager.INSTALL_FAILED_INVALID_APK;
+                            return null;
+                        }
+                        Slog.i(TAG, "Package installed with second ABI Library: " + pkg.applicationInfo.uid + pkg.applicationInfo.processName);
+                        mPackagesMatchABI2.put(pkg.applicationInfo.uid, pkg.applicationInfo.processName);
+                        writeAppwithABI2();
+                        if (check.doCheck(pkgName, new String("neon"))) {
+                            mPackagesMatchABI2Neon.put(pkg.applicationInfo.uid, pkg.applicationInfo.processName);
+                            writeAppwithABI2Neon();
+                        }
+                    }
+
                     if (DEBUG_INSTALL) Slog.i(TAG, "Linking native library dir for " + path);
                     final int[] userIds = sUserManager.getUserIds();
                     synchronized (mInstallLock) {
@@ -6115,6 +6227,18 @@ public class PackageManagerService extends IPackageManager.Stub {
             final PackageParser.Package pkg = ps.pkg;
             if (pkg != null) {
                 cleanPackageDataStructuresLILPw(pkg, chatty);
+
+                Integer pkgUidInt = new Integer(pkg.applicationInfo.uid);
+                if (ENABLE_HOUDINI && mPackagesMatchABI2.containsKey(pkgUidInt)) {
+                    Slog.i(TAG, "Uninstall package with second ABI Library");
+                    mPackagesMatchABI2.remove(pkgUidInt);
+                    writeAppwithABI2();
+                    if (mPackagesMatchABI2Neon.containsKey(pkgUidInt)) {
+                        mPackagesMatchABI2Neon.remove(pkgUidInt);
+                        writeAppwithABI2Neon();
+                    }
+                }
+
             }
         }
     }
@@ -6132,6 +6256,17 @@ public class PackageManagerService extends IPackageManager.Stub {
                 mAppDirs.remove(pkg.mPath);
             }
             cleanPackageDataStructuresLILPw(pkg, chatty);
+
+            if (ENABLE_HOUDINI && mPackagesMatchABI2.containsKey(new Integer(pkg.applicationInfo.uid))) {
+                Slog.i(TAG, "Uninstall package with second ABI Library");
+                mPackagesMatchABI2.remove(new Integer(pkg.applicationInfo.uid));
+                writeAppwithABI2();
+                if (mPackagesMatchABI2Neon.containsKey(new Integer(pkg.applicationInfo.uid))) {
+                    mPackagesMatchABI2Neon.remove(new Integer(pkg.applicationInfo.uid));
+                    writeAppwithABI2Neon();
+                }
+            }
+
         }
     }
 
@@ -9009,8 +9144,15 @@ public class PackageManagerService extends IPackageManager.Stub {
             }
             try {
                 int copyRet = copyNativeLibrariesForInternalApp(codeFile, nativeLibraryFile);
-                if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
-                    return copyRet;
+                if (ENABLE_HOUDINI) {
+                    if (copyRet != PackageManager.INSTALL_SUCCEEDED
+                            && copyRet != PackageManager.INSTALL_ABI2_SUCCEEDED) {
+                        return copyRet;
+                    }
+                } else {
+                    if (copyRet != PackageManager.INSTALL_SUCCEEDED) {
+                        return copyRet;
+                    }
                 }
             } catch (IOException e) {
                 Slog.e(TAG, "Copying native libraries failed", e);
diff --git a/services/java/com/android/server/pm/xmlCheckExt.java b/services/java/com/android/server/pm/xmlCheckExt.java
index e69de29..9864d42 100644
--- a/services/java/com/android/server/pm/xmlCheckExt.java
+++ b/services/java/com/android/server/pm/xmlCheckExt.java
@@ -0,0 +1,123 @@
+package com.android.server.pm;
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.List;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import android.app.Activity;
+import android.content.res.AssetManager;
+import android.util.Log;
+import android.util.Xml;
+
+/*
+ * class xmlCheckExt is trying to check by xml rules definition
+ */
+public class xmlCheckExt implements ICheckExt {
+    final private String TAG = "xmlCheckExt";
+    final private String CHECKXMLPATH = "/system/lib/arm/check.xml";
+    private HashMap<String,String > mMap = new  HashMap<String,String >();
+
+    public boolean doCheck(String... params) {
+        String param = null;
+        String param_tag = null;
+        InputStream in=null;
+        try {
+            int eventType;
+            String tag;
+            if (params.length == 0)
+                return false;
+            param = params[0];
+            param_tag = params[1];
+            XmlPullParser xmlParser = Xml.newPullParser();
+            File file = new File(CHECKXMLPATH);
+            if (!file.exists())
+                return false;
+            in = new FileInputStream(file);
+            xmlParser.setInput(in, "utf-8");
+
+            eventType = xmlParser.getEventType();
+            while (eventType != XmlPullParser.END_DOCUMENT) {
+                switch (eventType) {
+                case XmlPullParser.START_TAG:
+                    tag = xmlParser.getName();
+                    Log.d(TAG,"<"+tag+">");
+                    addTag(tag, xmlParser.nextText());
+                    break;
+                case XmlPullParser.END_TAG:
+                    tag = xmlParser.getName();
+                    Log.d(TAG,"</"+tag+">");
+                    break;
+                default:
+                    break;
+                }
+                eventType = xmlParser.next();
+            }
+        } catch (XmlPullParserException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (FileNotFoundException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+
+        try {
+            if (in != null)
+                in.close();
+        } catch (IOException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        return checkPkgName(param, param_tag);
+    }
+
+    /*Function:checkTag
+     *Description:
+     * add tag name to hash map
+     *Parameter:
+     * tag - tag name in xml
+     * text - text for the tag
+     *Return:
+     * true
+     */
+    boolean addTag(String tag, String text) {
+        String pkgName = text;
+        Log.d(TAG, " pkgName = " + pkgName);
+        if(!mMap.containsKey(pkgName))
+            mMap.put(pkgName,tag);
+        return true;
+    }
+
+    boolean checkPkgName(String pkgName, String tag) {
+        String value = mMap.get(pkgName);
+        if (value == null)
+            return false;
+        else
+            return value.equals(tag);
+    }
+
+}
diff --git a/services/jni/com_android_server_VibratorService.cpp b/services/jni/com_android_server_VibratorService.cpp
index 2b3f74a..a9b81d5 100644
--- a/services/jni/com_android_server_VibratorService.cpp
+++ b/services/jni/com_android_server_VibratorService.cpp
@@ -22,40 +22,68 @@
 
 #include <utils/misc.h>
 #include <utils/Log.h>
-#include <hardware_legacy/vibrator.h>
+#include <hardware/vibrator.h>
 
 #include <stdio.h>
+#include <assert.h>
 
-namespace android
+namespace android {
+
+static struct vibrator_module *gVibraModule;
+
+static void vibratorControlInit()
 {
+    assert(!gVibraModule);
+    int err;
+
+    err = hw_get_module(VIBRATOR_HARDWARE_MODULE_ID, (hw_module_t const**)&gVibraModule);
+
+    if (err) {
+      ALOGE("Couldn't load %s module (%s)", VIBRATOR_HARDWARE_MODULE_ID, strerror(-err));
+    }
+}
 
 static jboolean vibratorExists(JNIEnv *env, jobject clazz)
 {
-    return vibrator_exists() > 0 ? JNI_TRUE : JNI_FALSE;
+    return (gVibraModule && gVibraModule->vibrator_exists() > 0) ? JNI_TRUE : JNI_FALSE;
 }
 
 static void vibratorOn(JNIEnv *env, jobject clazz, jlong timeout_ms)
 {
-    // ALOGI("vibratorOn\n");
-    vibrator_on(timeout_ms);
+    if (gVibraModule) {
+        gVibraModule->vibrator_on(timeout_ms);
+    }
 }
 
 static void vibratorOff(JNIEnv *env, jobject clazz)
 {
-    // ALOGI("vibratorOff\n");
-    vibrator_off();
+    if (gVibraModule) {
+        gVibraModule->vibrator_off();
+    }
+}
+
+static jlong getVibratorMinTimeout(JNIEnv *env, jobject clazz)
+{
+    if (gVibraModule) {
+         return (jlong)gVibraModule->get_vibrator_min_timeout();
+    }
+    return 0;
 }
 
 static JNINativeMethod method_table[] = {
     { "vibratorExists", "()Z", (void*)vibratorExists },
     { "vibratorOn", "(J)V", (void*)vibratorOn },
-    { "vibratorOff", "()V", (void*)vibratorOff }
+    { "vibratorOff", "()V", (void*)vibratorOff },
+    { "getVibratorMinTimeout", "()J", (void*)getVibratorMinTimeout },
 };
 
 int register_android_server_VibratorService(JNIEnv *env)
 {
+    // Load vibrator hardware module
+    vibratorControlInit();
+
     return jniRegisterNativeMethods(env, "com/android/server/VibratorService",
             method_table, NELEM(method_table));
 }
 
-};
+}; // namespace android
